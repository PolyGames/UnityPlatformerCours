# UnityPlatformer - Cours Unity pour débutants par Poly Games

## Introduction
Le but de ce tutoriel est de montrer la base de Unity pour ceux qui ne l'ont jamais utilisé. Certains aspects sont simplifiés ou pas nécessairement faits de la manière la plus optimale possible. Le but est de faire un prototype qui est suffisamment simple, mais qui aborde une bonne variété de concepts pertinents et qui ne compromet pas trop la qualité en faveur de la simplicité. Par exemple, le prototype est simpliste, mais une particule ne passe pas à travers le sol, le joueur n'accélère pas instantanément à sa vitesse terminale et un objet ramassé ne fait pas que disparaitre instantanément. L'immersion du joueur est facile à briser, c'est pourquoi je crois qu'il est important de penser à ces problèmes qui peuvent être parfois faciles à résoudre mais qui devraient être pris en considération dès le début de l'apprentissage, peu importe l'engin utilisé.

Pour commencer avec Unity et faire un projet initial, je suggère fortement d'utiliser le Unity Hub. Ce projet a été créé initialement avec la version 2021.1.17f1. Quand vous faites "New Project", vous pouvez sélectionner le template "3D" et faire "Create Project". Vous pouvez également ouvrir un projet déjà existant, tel que celui-ci, à partir du Unity Hub. Il suffit de le télécharger, et puis de l'ouvrir avec "Open" en prenant soin de sélectionner le dossier de base du projet. Pour ce tutoriel, je vous suggère de créer un nouveau projet et d'avoir les fichiers de ce projet sur votre ordinateur afin de pouvoir les consulter ou de pouvoir ouvrir et comparer ce projet avec votre propre version au besoin. 

#### Interface
Unity permet de déplacer les fenêtres pour obtenir une configuration adaptée à vos besoins. Vous pouvez cliquer sur le nom de la fenêtre et la glisser où vous voulez. 
 - La fenêtre « Scene » permet de visualiser la scène, c'est-à-dire le niveau, ainsi que tous les objets contenus dans le niveau, qui sont appelés des GameObjects. En maintenant le bouton droit de la souris, vous pouvez tourner la caméra sur son propre axe et déplacer la caméra avec W, A, S, D. Vous pouvez également cliquer sur les objets dans la scène pour les sélectionner et les déplacer avec les flèches. Avec les outils que vous pouvez sélectionner en haut à gauche de l'éditeur, vous pouvez soit vous déplacer dans la scène avec la main, déplacer des objets avec les flèches, tourner les objets ou changer la mise à l'échelle des objets.
 - La fenêtre « Hierarchy » permet de voir les GameObjects présent dans la scène. On peut y voir les objets et les relations entre les objets. Pour faire en sorte qu'un objet soit "enfant" d'un autre objet, vous pouvez le cliquer, le maintenir et le glisser sur un autre objet. L'objet enfant sera maintenant déplacé en même temps que son objet parent, et si l'objet parent est détruit, tous les objets enfants seront détruits. Vous pouvez sélectionner un ou des objets et vous pouvez faire un clic droit dans la hiérarchie pour manipuler les objets sélectionnés ou créer un nouvel objet.
 - La fenêtre « Game » permet de voir ce qui sera affiché au joueur lors de l'exécution du jeu. Le bouton "Play" en haut au milieu de l'éditeur permet de démarrer le jeu. Vous pouvez cliquer à nouveau sur le bouton pour désactiver l'exécution du jeu, ou cliquer sur le bouton "Pause" pour interrompre l'exécution. Le troisième bouton permet de poursuivre l'exécution pour seulement une trame.
 - La fenêtre « Inspector » permet de modifier les paramètres d'un GameObject sélectionné dans la hiérarchie. Un GameObject est essentiellement un regroupement de "Components", ou de "composantes". Chaque composante possède des attributs qui peuvent être changés, et chaque GameObject possède par défaut la composante Transform, qui représente la position, la rotation et l'échelle de l'objet. Lorsque vous créez un objet autrement qu'avec un clic droit suivi de "Create Empty", vous créez un objet qui vient déjà avec quelques composantes. Par exemple, si vous créez un cube, celui-ci viendra déjà avec son affichage (Mesh Renderer et Mesh Filter), et avec sa forme de collision (Box Collider). Les composantes peuvent être activées ou désactivées. Par exemple, si un objet doit, à un certain moment, perdre sa tangibilité, alors il est possible par divers moyens de désactiver seulement la composante du Box Collider. Dans l'éditeur, il est possible de le faire en cliquant sur le crochet visible à gauche du nom "Box Collider". Vous pouvez également créer vos propres composantes. Nous y viendrons plus tard dans ce tutoriel.
 - La fenêtre « Project » permet de visualiser l'ensemble des Assets, c'est-à-dire les fichiers ou les ressources présentes et disponible pour votre utilisation dans le jeu, que ce soit du code, des modèles, des textures, du son ou bien d'autres. Avec un clic droit dans cette fenêtre, vous pouvez créer différents assets selon vos besoins.
D'autres fenêtres seront également pertinentes lors de ce tutoriel, comme l'Animator, l'Animation, la Console et les Project Settings. Nous y viendrons au moment où ces fenêtres seront nécessaires.

#### Boucle d'exécution
Les jeux fonctionnent avec une boucle qui s'exécute à chaque trame du jeu. Quand un niveau est chargé et lancé, une fonction d'initialisation est appelée pour chaque GameObject et pour chaque composante. À chaque trame, une fonction de mise à jour est appelée pour chaque composante de chaque GameObject présent et activé dans la scène. Cette boucle pourra être utilisée pour mettre à jour vos propres composantes, c'est-à-dire que vous pourrez implémenter du code qui sera appelé à chaque trame afin de donner vos propres comportements à des GameObjects. Il existe plusieurs fonctions qui font partie de la boucle d'exécution, mais les deux plus importantes sont Start et Update. Nous verrons en détail comment créer une composante afin d'ajouter notre propre logique au jeu dans la section suivante de ce tutoriel.

## Niveau et Joueur
Nous allons maintenant voir comment créer des objets dans la scène qui serviront de base pour un niveau, ainsi qu'un objet servant d'avatar que le joueur contrôlera.

#### Création du sol et d'objets
L'espace est présentement vide, sauf pour une caméra et une lumière. Pour créer un sol de base servant à implémenter la suite du prototype, vous pouvez faire un clic droit dans la hiérarchie, faire 3D Object, puis Plane. Vous pouvez nommer le plan "Ground", et dans la fenêtre d'inspecteur, vous pouvez changer le Scale pour 5, 1, 5, ce qui fera un plan suffisamment grand pour implémenter le déplacement. Le plan possède déjà les composantes requises, c'est-à-dire un Mesh Renderer et un Mesh Collider. Dans la hiérarchie, vous pouvez créer un objet 3D "Capsule" qui servira d'avatar temporaire pour le joueur. Vous pouvez placer le joueur légèrement en haut du plan, et lorsque le jeu sera exécuté, il tombera sur le plan. Pour qu'il soit affecté par le système de physique de Unity, il faut ajouter au joueur la composante "Rigidbody". Vous pouvez ajouter n'importe quelle composante à n'importe que GameObject en sélectionnant le GameObject dans la hiérarchie, et puis en sélectionnant le bouton Add Component dans l'inspecteur et en cherchant "Rigidbody". Puisque le plan n'a pas de Rigidbody, celui-ci ne peut pas tomber, alors que le joueur tombe et entre en collision avec le plan.

#### Déplacement de base
Pour faire en sorte que le joueur puisse se déplacer avec les touches du clavier, il faut créer une composante. Pour commencer, vous pouvez sélectionner l'objet qui représente le joueur, aller dans l'inspecteur et faire "Add Component". Cette fois-ci, vous pouvez écrire "PlayerMovement" et faire New Script pour créer le script C# qui contiendra le code de la composante que nous allons créer. Le nouveau script est maintenant ajouté au projet, vous pouvez aller dans la fenêtre Project, puis trouver votre nouvelle composante et la double cliquer pour que le script s'ouvre dans Visual Studio. Vous pouvez également double cliquer sur le nom du script dans l'inspecteur pour l'ouvrir. Dans le script, il y a les deux fonctions de base, Start et Update. Vous pouvez faire une nouvelle fonction, GetInputs, que vous pouvez appeler dans Update. L'idée derrière cette fonction, c'est de récupérer toutes les entrées nécessaires aux déplacements du joueur pour la trame actuelle, que ce soit une entrée au clavier ou une information du monde qui nous sera importante. Pour l'instant, la fonction GetInputs devra ressembler à ceci: 

```
    private void GetInputs()
    {
        inputVector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
        inputVector.Normalize();
    }
```

Cette fonction récupère deux Axes d'Input. Ces axes sont configurés par défauts mais vous pouvez les configurer vous-mêmes dans Edit/Project Settings/Input Manager. Le nom de l'axe à récupérer est important, car il doit être écrit exactement dans la fonction GetAxis. Un axe a une valeur qui peut varier entre -1 et 1. Au repos, l'axe est à 0, il peut y avoir un bouton négatif pour faire graduellement changer la valeur jusqu'à -1, et un bouton positif pour faire graduellement changer la valeur jusqu'à 1. Dans le cas de l'axe Horizontal et Vertical, ceux-ci devraient déjà être configurés correctement par défaut. Une fois récupéré, les deux valeurs sont mises dans un Vector2, composé de deux floats, qui serviront d'entrées pour le déplacement du joueur. Le vecteur est ensuite normalisé afin que, même si le déplacement soit à la fois vertical et horizontal, la norme du vecteur d'input soit toujours de 1. 

Nous avons vu comment récupérer les valeurs du clavier et les mettre dans un vecteur, mais maintenant il faut utiliser ces valeurs afin de causer un déplacement du joueur. Ceci peut être accompli de plusieurs manières, mais pour déplacer le joueur, ce sera fait en calculant soi-même une vélocité que nous utiliserons pour modifier la position du joueur. D'autres manières sont également valides, mais celle-ci permet un bon niveau de contrôle sur le déplacement du joueur.

```
private void FixedUpdate()
    {
        float verticalVelocity = velocity.y;
        velocity = CalculateVelocity();
        velocity.y = verticalVelocity;
        Vector3 movement = velocity * Time.deltaTime;

        Body.MovePosition(transform.position + movement);
    }
```

Vous pouvez consulter le code dans ce repo afin de voir comment est implémenté la fonction CalculateVelocity, et aussi ajouter les variables concernés et manquantes. Dans la fonction Update, après le GetInput, il faut mettre à jour une "targetVelocity", que vous pourriez utiliser directement en tant que velocity dans le calcul du mouvement de FixedUpdate, mais en l'utilisant ainsi, le déplacement devient instantané. Il faut une certaine accélération de la vélocité actuelle jusqu'à celle voulu, soit la targetVelocity, pour que le mouvement ne soit pas aussi soudain. En regardant le code fourni, vous avez surement remarqué que certaines variables possèdent un attribut ```[SerializeField]``` devant certaines variables. L'utilité de cet attribut est qu'il permet d'exposer la variable dans l'éditeur. En d'autres termes, avec cet attribut, vous pouvez modifier la valeur directement dans l'inspecteur au lieu de modifier la valeur dans le code, ce qui est très utile pour modifier la valeur pendant l'exécution pour trouver la meilleure valeur, ou encore pour avoir plusieurs objets avec la composante et donner des valeurs différentes, comme des ennemis qui auraient des quantités de points de vie différentes mais qui utilisent le même script. C'est également pratique pour des Game Designers afin qu'ils puissent ajuster les valeurs dans l'éditeur au lieu de devoir consulter le code. Si vous ajoutez les fonctions et les variables nécessaires, votre joueur devrait maintenant tomber vers le sol et être mobile lorsque vous pesez sur les touches W, A, S, D.
Une autre utilité importante est pour permettre d'exposer des variables références dans l'éditeur. Quand l'attribut ```[SerializeField]``` est mis devant une variable qui n'est pas un type de base, alors Unity s'attends à ce qu'une référence correspondante y soit rattachée. Dans l'éditeur, vous remarquerez que le champ correspondant à la variable devient vide. Vous pouvez y glisser un objet sélectionné afin de d'attacher la référence. Par exemple, en ce moment, il y a le Body du script de joueur qui n'a pas encore de référence. Vous pouvez ajouter au script la variable Body de type Rigidbody avec l'attribut, puis retourner dans l'éditeur, et glisser, à partir de la hiérarchie, le GameObjet ayant la composante "Rigidbody" jusqu'au champ du script. Dans ce cas-ci, vous devez cliquer sur le GameObject du joueur dans la hiérarchie, et vous remarquerez dans l'inspecteur qu'il a à la fois la composante Rigidbody et la composante créée par script. Il suffit donc de glisser le GameObject de la hiérarchie jusqu'à l'inspecteur et de le placer dans le champ de la variable Body, ce qui donnera la référence. Comme la variable est de type Rigidbody, et que le GameObject possède une composante de ce type, alors sa composante est utilisée pour faire la référence. 

#### Saut
Il existe plusieurs manières de faire un saut dans Unity. Une manière simple est d'accéder au Rigidbody du joueur et d'appeler la méthode "AddForce". Dans plusieurs jeux, le personnage saute plus haut lorsque le bouton de saut est maintenu que lorsqu'il est enfoncé qu'une fois. Pour le but de l'atelier, je vais vous montrer une manière de faire un saut de cette dernière manière.

Tout d'abord, il faut récupérer l'état du bouton de saut. On peut le faire d'une manière semblable aux axes et récupérer l'axe nommé "Jump" sous forme de bouton, pour que son état soit un booléen. Ensuite, il faut une manière de déterminer que notre personnage touche au sol ou non. Vous pouvez utiliser un court tracé de rayon à partir d'un point près des pieds du joueur vers le bas. Pour se faire, nous ajoutons un GameObject comme enfant de l'objet du joueur, que l'on nomme "FeetTransform" et qui doit être à la position 0 mis à part pour Y qui doit être à -0,95. On peut vérifier si le joueur touche au sol dans la fonction GetInputs:

```
    private void GetInputs()
    {
        inputVector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
        inputVector.Normalize();
        isJumpingButtonDown = Input.GetButton("Jump");

        isGrounded = Physics.Raycast(FeetTransform.position, Vector3.down, 0.1f);
    }
```

La variable de type Transform, soit le FeetTransform, doit être initialisé comme le Rigidbody. C'est-à-dire qu'il doit être un ```[SerializeField]``` dans le code, et que vous devez cliquer l'objet contenant la composante concernée (soit le Transform du GameObject FeetTransform), et glisser cet objet sur le champ correspondant à FeetTransform dans le script du joueur dans l'inspecteur. En étapes simples, vous devez: Cliquer sur le joueur dans la hiérarchie pour que ses composantes apparaissent dans l'inspecteur, descendre dans l'inspecteur jusqu'à voir le champ FeetTransform, cliquer et maintenir le bouton de la souris enfoncé pour glisser jusqu'au champ et créer le lien entre le GameObject FeetTransform visible dans la hiérarchie, et la variable FeetTransform présente dans le code.  
La fonction de Raycast crée un tracé de rayon à partir de la position des pieds, vers le bas avec "Vector3.down", et d'une distance de 0.1f. La suite du saut est implémentée dans FixedUpdate après le déplacement de la position. L'implémentation consiste à mettre la vélocité en Y du Rigidbody à une certaine valeur. Nous voulons que, lorsque le bouton est relâché ou lorsqu'un certain temps est atteint, le saut est considéré comme arrêté et complet. Vous pouvez ajouter à FixedUpdate:

```
    if (isJumpingButtonDown && isGrounded && !isJumpActivated)
    {
        isJumping = true;
        StartCoroutine(JumpTimerCoroutine());
    }
    if (isJumping && !isJumpingButtonDown)
    {
        isJumpActivated = false;
    }
    if (isJumpActivated)
    {
        Vector3 velocityBeforeJump = Body.velocity;
        velocityBeforeJump.y = JumpForce;
        Body.velocity = velocityBeforeJump;
    }
```

On utilise les Coroutines afin de faire un compteur de temps. Lorsque le saut doit être activé, la coroutine est démarrée et elle est exécutée en manière séquentielle par rapport au reste du code. Contrairement à appeler une fonction, la coroutine n'arrête pas l'exécution courante, ce qui permet de poursuivre l'exécution du code du joueur. Dans la coroutine, on active le saut, on attend pour le temps de saut voulu, et puis on désactive le saut.

## Prefabs, Particules et Animations
Dans le code, vous pouvez remarquer à certains endroits des appels à l'animateur. Pour l'atelier, nous allons ajouter un système de particules au saut et il sera contrôlé par le système d'animations de Unity.

#### Prefabs
Les "Prefabs" sont en quelque sorte un objet de la scène que l'on souhaite sérialiser, c'est-à-dire en faire un objet qui sera présent dans les Assets. Il y a plusieurs avantages à faire des prefabs, comme le fait que notre joueur ne dépendra plus du niveau, on pourra le réutiliser dans n'importe quel niveau, et on peut instancier un prefab par code pour générer des objets par exemple. Pour créer le prefab du joueur, il suffit de sélectionner le joueur dans la hiérarchie du niveau, et de le glisser dans la fenêtre Project. Son nom dans la hiérarchie deviendra bleu, et il sera maintenant possible de modifier le joueur directement en l'ouvrant à partir de la fenêtre Project, ce qui modifiera toutes les instances du joueur présent dans les niveaux. 

#### Particules
Le système de particules de Unity permet de faire de très nombreux effets visuels variés. Vous pouvez ouvrir le prefab du joueur et lui ajouter un GameObject pour les particules avec un clic droit dans la hiérarchie suivi de Effects/Particle System. En sélectionnant le particle system dans la hiérarchie, celui-ci devient configurable dans l'inspecteur et un aperçu est affiché dans la fenêtre de scène. Quelques changements sont nécessaires pour le système: on veut qu'il projette vers le bas, que les particules passent d'un gris foncé de départ jusqu'au noir et puis au transparent, et on veut que les particules entrent en collision avec le sol pour que les particules ne passent pas au travers. 
Je vous suggère fortement d'ouvrir le projet fourni afin de voir les différents réglages et de comprendre les changements faits par rapport au système de particules de base. Par défaut, les particules agissent comme si elles étaient enfant du GameObject qui contient la composante de Particle System. Pour que les particules puissent être créées puis envoyées dans le monde sans suivre le joueur, il faut changer l'option Simulation Space à World. Sa forme doit également être changée, vous pouvez donc aller dans Shape, sélectionner un cône, puis configurer l'angle et le rayon du cône. Vous pouvez tourner le système de particules pour que sa rotation soit à 90 en X et le mettre à une position semblable à celle des pieds, et le système devrait maintenant projeter les particules vers le bas. Vous pouvez aussi changer la vitesse de départ ainsi que les paramètres d'émission afin de projeter un plus grand nombre de particules. Vous pouvez activer "Color over Lifetime" dans l'inspecteur pour que la couleur des particules puisse changer. Dans "Color over Lifetime", vous pouvez cliquer sur la couleur afin d'ouvrir un éditeur de gradient qui vous permettra de changer la couleur de départ, de fin, et la transparence. Pour activer la collision, vous pouvez activer "Collision" dans l'inspecteur. Nous voulons que ces particules entrent en collisions avec certains objets mais pas nécessairement tous les objets, comme le joueur par exemple. Pour exclure certaines collisions, il faut créer une nouvelle couche, soit une nouvelle Layer. Vous pouvez retourner dans la scène (il suffit de cliquer sur le bouton à gauche du nom du prefab dans la hiérarchie, la flèche qui pointe vers la gauche), sélectionner le sol, et vous pourrez constater que le Layer, dans l'inspecteur, n'est pas configuré pour le sol. Vous pouvez cliquer sur le menu déroulant, faire Add Layer, puis créer un Layer nommé Ground. Assurez-vous que le sol possède maintenant ce Layer, puis réouvrez le prefab du joueur pour sélectionner le particle system et changer l'option "Collides With" pour la mettre à "Ground".

#### Animations
Vous devriez maintenant avoir, lorsque vous exécutez le jeu: un joueur qui se déplace sur le niveau, qui saute, et qui projette des particules vers le bas. Par contre, nous voulons que les particules ne soient projetés que lorsque le joueur est en saut. Pour se faire, nous allons utiliser le système d'animations de Unity. Ce système n'est pas utile qu'aux animations, il s'agit avant tout d'un système constitué d'une machine à états. Dans le prefab du joueur, sélectionnez le GameObject racine, puis ajoutez lui la composante "Animator". Dans le projet, vous pouvez ajouter un dossier Player dans lequel on peut mettre le prefab du joueur, et dans lequel vous pouvez créer un Animator Controller avec le clic droit suivi de Create. Vous devez maintenant lier le fichier créé à la composante présente dans le GameObject du joueur. Vous pouvez cliquer sur le Animator Controller dans la fenêtre Project, et le glisser dans le champ "Controller" de la composante "Animator" du GameObject du joueur. Lorsque vous double cliquez dans la fenêtre Project sur le contrôleur créé, une fenêtre Animator devrait s'ouvrir. Vous pouvez sélectionner le nom de la fenêtre et la glisser à côté du nom de la fenêtre scène, ou mettre la fenêtre où vous voulez. Si vous voulez animer le joueur, ce sera avec ce contrôleur. Pour le but de l'atelier, on se contentera de contrôler le système de particules. Vous pouvez créer une nouvelle Layer d'animation en sélectionnant l'onglet Layer de la fenêtre d'Animator, puis en cliquant sur le "+". Vous pouvez nommer la Layer "Thrusters". Il n'y aura que deux animations nécessaires: ThrusterStart et ThrusterStop. Vous pouvez les créer dans la fenêtre Project de la même manière que vous avez créé le Animator Controller, leur donner le nom voulu, puis les sélectionner et les glisser dans la fenêtre de Animator pour les ajouter au contrôleur. On voudra une transition de ThrusterStart à ThrusterStop et une transition de ThrusterStop à ThrusterStart. Vous pouvez faire un clic droit sur un état, faire "Make Transition", puis cliquer sur l'état suivant. Vous devez sélectionner les transitions et désactiver l'option "Has Exit Time", ce qui forcera Unity à vous demander d'établir une condition de transition. Pour ce faire, vous devez créer un paramètre d'animation. Vous devez donc cliquer sur l'onglet Parameters, créer un nouveau booléen appelé IsThrustersActivated. Nous activerons et désactiverons ce booléen dans le code, ce qui permettra au système de faire les transitions.
Dans le code, vous pouvez créer la variable d'Animator, utiliser ```[SerializeField]```, faire le lien entre la composante Animator du GameObject dans la variable Animator du script de la même manière que pour le Rigidbody et le FeetTransform. Il suffit maintenant d'ajouter ```Animator.SetBool("IsThrustersActivated", true);``` pour causer la transition, et à ```false``` pour causer la transition inverse. Vous pouvez ajouter cette ligne à la fin de la coroutine, et dans les ```if``` de FixedUpdate. D'une manière similaire, si l'on souhaite passer un paramètre de type float, on utiliserait SetFloat. 
Maintenant il faut ajouter de l'information dans les animations afin que celles-ci puissent en effet activer et désactiver le système de particules. Vous pouvez faire Window/Animation/Animation pour ouvrir la fenêtre qui permet de modifier une animation. Lorsque vous aurez ouvert le prefab du joueur et sélectionner son GameObject qui a la composante Animator, la fenêtre Animation aura un menu déroulant contenant toutes les animations du contrôleur d'animation. 



