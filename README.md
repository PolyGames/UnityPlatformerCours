# UnityPlatformer - Cours Unity pour débutants par Poly Games

## Introduction
Le but de ce tutoriel est de montrer la base de Unity pour ceux qui ne l'ont jamais utilisé. Certains aspects sont simplifiés ou pas nécessairement faits de la manière la plus optimale possible. Le but est de faire un prototype qui est suffisamment simple, mais qui aborde une bonne variété de concepts pertinents et qui ne compromet pas trop la qualité en faveur de la simplicité. Par exemple, le prototype est simpliste, mais une particule ne passe pas à travers le sol, le joueur n'accélère pas instantanément à sa vitesse terminale et un objet ramassé ne fait pas que disparaitre instantanément. L'immersion du joueur est facile à briser, c'est pourquoi je crois qu'il est important de penser à ces problèmes qui peuvent être parfois faciles à résoudre mais qui devraient être pris en considération dès le début de l'apprentissage, peu importe l'engin utilisé.

Pour commencer avec Unity et faire un projet initial, je suggère fortement d'utiliser le Unity Hub. Ce projet a été créé initialement avec la version 2021.1.17f1. Quand vous faites "New Project", vous pouvez sélectionner le template "3D" et faire "Create Project". Vous pouvez également ouvrir un projet déjà existant, tel que celui-ci, à partir du Unity Hub. Il suffit de le télécharger, et puis de l'ouvrir avec "Open" en prenant soin de sélectionner le dossier de base du projet. Pour ce tutoriel, je vous suggère de créer un nouveau projet et d'avoir les fichiers de ce projet sur votre ordinateur afin de pouvoir les consulter ou de pouvoir ouvrir et comparer ce projet avec votre propre version au besoin. 

#### Interface
Unity permet de déplacer les fenêtres pour obtenir une configuration adaptée à vos besoins. Vous pouvez cliquer sur le nom de la fenêtre et la glisser où vous voulez. 
 - La fenêtre « Scene » permet de visualiser la scène, c'est-à-dire le niveau, ainsi que tous les objets contenus dans le niveau, qui sont appelés des GameObjects. En maintenant le bouton droit de la souris, vous pouvez tourner la caméra sur son propre axe et déplacer la caméra avec W, A, S, D. Vous pouvez également cliquer sur les objets dans la scène pour les sélectionner et les déplacer avec les flèches. Avec les outils que vous pouvez sélectionner en haut à gauche de l'éditeur, vous pouvez soit vous déplacer dans la scène avec la main, déplacer des objets avec les flèches, tourner les objets ou changer la mise à l'échelle des objets.
 - La fenêtre « Hierarchy » permet de voir les GameObjects présent dans la scène. On peut y voir les objets et les relations entre les objets. Pour faire en sorte qu'un objet soit "enfant" d'un autre objet, vous pouvez le cliquer, le maintenir et le glisser sur un autre objet. L'objet enfant sera maintenant déplacé en même temps que son objet parent, et si l'objet parent est détruit, tous les objets enfants seront détruits. Vous pouvez sélectionner un ou des objets et vous pouvez faire un clic droit dans la hiérarchie pour manipuler les objets sélectionnés ou créer un nouvel objet.
 - La fenêtre « Game » permet de voir ce qui sera affiché au joueur lors de l'exécution du jeu. Le bouton "Play" en haut au milieu de l'éditeur permet de démarrer le jeu. Vous pouvez cliquer à nouveau sur le bouton pour désactiver l'exécution du jeu, ou cliquer sur le bouton "Pause" pour interrompre l'exécution. Le troisième bouton permet de poursuivre l'exécution pour seulement une trame.
 - La fenêtre « Inspector » permet de modifier les paramètres d'un GameObject sélectionné dans la hiérarchie. Un GameObject est essentiellement un regroupement de "Components", ou de "composantes". Chaque composante possède des attributs qui peuvent être changés, et chaque GameObject possède par défaut la composante Transform, qui représente la position, la rotation et l'échelle de l'objet. Lorsque vous créez un objet autrement qu'avec un clic droit suivi de "Create Empty", vous créez un objet qui vient déjà avec quelques composantes. Par exemple, si vous créez un cube, celui-ci viendra déjà avec son affichage (Mesh Renderer et Mesh Filter), et avec sa forme de collision (Box Collider). Les composantes peuvent être activées ou désactivées. Par exemple, si un objet doit, à un certain moment, perdre sa tangibilité, alors il est possible par divers moyens de désactiver seulement la composante du Box Collider. Dans l'éditeur, il est possible de le faire en cliquant sur le crochet visible à gauche du nom "Box Collider". Vous pouvez également créer vos propres composantes. Nous y viendrons plus tard dans ce tutoriel.
 - La fenêtre « Project » permet de visualiser l'ensemble des Assets, c'est-à-dire les fichiers ou les ressources présentes et disponible pour votre utilisation dans le jeu, que ce soit du code, des modèles, des textures, du son ou bien d'autres. Avec un clic droit dans cette fenêtre, vous pouvez créer différents assets selon vos besoins.
D'autres fenêtres seront également pertinentes lors de ce tutoriel, comme l'Animator, l'Animation, la Console et les Project Settings. Nous y viendrons au moment où ces fenêtres seront nécessaires.

#### Boucle d'exécution
Les jeux fonctionnent avec une boucle qui s'exécute à chaque trame du jeu. Quand un niveau est chargé et lancé, une fonction d'initialisation est appelée pour chaque GameObject et pour chaque composante. À chaque trame, une fonction de mise à jour est appelée pour chaque composante de chaque GameObject présent et activé dans la scène. Cette boucle pourra être utilisée pour mettre à jour vos propres composantes, c'est-à-dire que vous pourrez implémenter du code qui sera appelé à chaque trame afin de donner vos propres comportements à des GameObjects. Il existe plusieurs fonctions qui font partie de la boucle d'exécution, mais les deux plus importantes sont Start et Update. Nous verrons en détail comment créer une composante afin d'ajouter notre propre logique au jeu dans la section suivante de ce tutoriel.

## Niveau et Joueur
Nous allons maintenant voir comment créer des objets dans la scène qui serviront de base pour un niveau, ainsi qu'un objet servant d'avatar que le joueur contrôlera.

#### Création du sol et d'objets
L'espace est présentement vide, sauf pour une caméra et une lumière. Pour créer un sol de base servant à implémenter la suite du prototype, vous pouvez faire un clic droit dans la hiérarchie, faire 3D Object, puis Plane. Vous pouvez nommer le plan "Ground", et dans la fenêtre d'inspecteur, vous pouvez changer le Scale pour 5, 1, 5, ce qui fera un plan suffisamment grand pour implémenter le déplacement. Le plan possède déjà les composantes requises, c'est-à-dire un Mesh Renderer et un Mesh Collider. Dans la hiérarchie, vous pouvez créer un objet 3D "Capsule" qui servira d'avatar temporaire pour le joueur. Vous pouvez placer le joueur légèrement en haut du plan, et lorsque le jeu sera exécuté, il tombera sur le plan. Pour qu'il soit affecté par le système de physique de Unity, il faut ajouter au joueur la composante "Rigidbody". Vous pouvez ajouter n'importe quelle composante à n'importe que GameObject en sélectionnant le GameObject dans la hiérarchie, et puis en sélectionnant le bouton Add Component dans l'inspecteur et en cherchant "Rigidbody". Puisque le plan n'a pas de Rigidbody, celui-ci ne peut pas tomber, alors que le joueur tombe et entre en collision avec le plan.

#### Déplacement de base
Pour faire en sorte que le joueur puisse se déplacer avec les touches du clavier, il faut créer une composante. Pour commencer, vous pouvez sélectionner l'objet qui représente le joueur, aller dans l'inspecteur et faire "Add Component". Cette fois-ci, vous pouvez écrire "PlayerMovement" et faire New Script pour créer le script C# qui contiendra le code de la composante que nous allons créer. Le nouveau script est maintenant ajouté au projet, vous pouvez aller dans la fenêtre Project, puis trouver votre nouvelle composante et la double cliquer pour que le script s'ouvre dans Visual Studio. Vous pouvez également double cliquer sur le nom du script dans l'inspecteur pour l'ouvrir. Dans le script, il y a les deux fonctions de base, Start et Update. Vous pouvez faire une nouvelle fonction, GetInputs, que vous pouvez appeler dans Update. L'idée derrière cette fonction, c'est de récupérer toutes les entrées nécessaires aux déplacements du joueur pour la trame actuelle, que ce soit une entrée au clavier ou une information du monde qui nous sera importante. Pour l'instant, la fonction GetInputs devra ressembler à ceci: 

```
    private void GetInputs()
    {
        inputVector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
        inputVector.Normalize();
    }
```

Cette fonction récupère deux Axes d'Input. Ces axes sont configurés par défauts mais vous pouvez les configurer vous-mêmes dans Edit/Project Settings/Input Manager. Le nom de l'axe à récupérer est important, car il doit être écrit exactement dans la fonction GetAxis. Un axe a une valeur qui peut varier entre -1 et 1. Au repos, l'axe est à 0, il peut y avoir un bouton négatif pour faire graduellement changer la valeur jusqu'à -1, et un bouton positif pour faire graduellement changer la valeur jusqu'à 1. Dans le cas de l'axe Horizontal et Vertical, ceux-ci devraient déjà être configurés correctement par défaut. Une fois récupéré, les deux valeurs sont mises dans un Vector2, composé de deux floats, qui serviront d'entrées pour le déplacement du joueur. Le vecteur est ensuite normalisé afin que, même si le déplacement soit à la fois vertical et horizontal, la norme du vecteur d'input soit toujours de 1. 

Nous avons vu comment récupérer les valeurs du clavier et les mettre dans un vecteur, mais maintenant il faut utiliser ces valeurs afin de causer un déplacement du joueur. Ceci peut être accompli de plusieurs manières, mais pour déplacer le joueur, ce sera fait en calculant soi-même une vélocité que nous utiliserons pour modifier la position du joueur. D'autres manières sont également valides, mais celle-ci permet un bon niveau de contrôle sur le déplacement du joueur.

```
private void FixedUpdate()
    {
        float verticalVelocity = velocity.y;
        velocity = CalculateVelocity();
        velocity.y = verticalVelocity;
        Vector3 movement = velocity * Time.deltaTime;

        Body.MovePosition(transform.position + movement);
    }
```

Vous pouvez consulter le code dans ce repo afin de voir comment est implémenté la fonction CalculateVelocity, et aussi ajouter les variables concernés et manquantes. Dans la fonction Update, après le GetInput, il faut mettre à jour une "targetVelocity", que vous pourriez utiliser directement en tant que velocity dans le calcul du mouvement de FixedUpdate, mais en l'utilisant ainsi, le déplacement devient instantané. Il faut une certaine accélération de la vélocité actuelle jusqu'à celle voulu, soit la targetVelocity, pour que le mouvement ne soit pas aussi soudain. En regardant le code fourni, vous avez surement remarqué que certaines variables possèdent un attribut ```[SerializeField]``` devant certaines variables. L'utilité de cet attribut est qu'il permet d'exposer la variable dans l'éditeur. En d'autres termes, avec cet attribut, vous pouvez modifier la valeur directement dans l'inspecteur au lieu de modifier la valeur dans le code, ce qui est très utile pour modifier la valeur pendant l'exécution pour trouver la meilleure valeur, ou encore pour avoir plusieurs objets avec la composante et donner des valeurs différentes, comme des ennemis qui auraient des quantités de points de vie différentes mais qui utilisent le même script. C'est également pratique pour des Game Designers afin qu'ils puissent ajuster les valeurs dans l'éditeur au lieu de devoir consulter le code. Si vous ajoutez les fonctions et les variables nécessaires, votre joueur devrait maintenant tomber vers le sol et être mobile lorsque vous pesez sur les touches W, A, S, D.
Une autre utilité importante est pour permettre d'exposer des variables références dans l'éditeur. Quand l'attribut ```[SerializeField]``` est mis devant une variable qui n'est pas un type de base, alors Unity s'attends à ce qu'une référence correspondante y soit rattachée. Dans l'éditeur, vous remarquerez que le champ correspondant à la variable devient vide. Vous pouvez y glisser un objet sélectionné afin de d'attacher la référence. Par exemple, en ce moment, il y a le Body du script de joueur qui n'a pas encore de référence. Vous pouvez ajouter au script la variable Body de type Rigidbody avec l'attribut, puis retourner dans l'éditeur, et glisser, à partir de la hiérarchie, le GameObjet ayant la composante "Rigidbody" jusqu'au champ du script. Dans ce cas-ci, vous devez cliquer sur le GameObject du joueur dans la hiérarchie, et vous remarquerez dans l'inspecteur qu'il a à la fois la composante Rigidbody et la composante créée par script. Il suffit donc de glisser le GameObject de la hiérarchie jusqu'à l'inspecteur et de le placer dans le champ de la variable Body, ce qui donnera la référence. Comme la variable est de type Rigidbody, et que le GameObject possède une composante de ce type, alors sa composante est utilisée pour faire la référence. 

#### Saut
Il existe plusieurs manières de faire un saut dans Unity. Une manière simple est d'accéder au Rigidbody du joueur et d'appeler la méthode "AddForce". Dans plusieurs jeux, le personnage saute plus haut lorsque le bouton de saut est maintenu que lorsqu'il est enfoncé qu'une fois. Pour le but de l'atelier, je vais vous montrer une manière de faire un saut de cette dernière manière.

Tout d'abord, il faut récupérer l'état du bouton de saut. On peut le faire d'une manière semblable aux axes et récupérer l'axe nommé "Jump" sous forme de bouton, pour que son état soit un booléen. Ensuite, il faut une manière de déterminer que notre personnage touche au sol ou non. Vous pouvez utiliser un court tracé de rayon à partir d'un point près des pieds du joueur vers le bas. Pour se faire, nous ajoutons un GameObject comme enfant de l'objet du joueur, que l'on nomme "FeetTransform" et qui doit être à la position 0 mis à part pour Y qui doit être à -0,95. On peut vérifier si le joueur touche au sol dans la fonction GetInputs:

```
    private void GetInputs()
    {
        inputVector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
        inputVector.Normalize();
        isJumpingButtonDown = Input.GetButton("Jump");

        isGrounded = Physics.Raycast(FeetTransform.position, Vector3.down, 0.1f);
    }
```

La variable de type Transform, soit le FeetTransform, doit être initialisé comme le Rigidbody. C'est-à-dire qu'il doit être un ```[SerializeField]``` dans le code, et que vous devez cliquer l'objet contenant la composante concernée (soit le Transform du GameObject FeetTransform), et glisser cet objet sur le champ correspondant à FeetTransform dans le script du joueur dans l'inspecteur. En étapes simples, vous devez: Cliquer sur le joueur dans la hiérarchie pour que ses composantes apparaissent dans l'inspecteur, descendre dans l'inspecteur jusqu'à voir le champ FeetTransform, cliquer et maintenir le bouton de la souris enfoncé pour glisser jusqu'au champ et créer le lien entre le GameObject FeetTransform visible dans la hiérarchie, et la variable FeetTransform présente dans le code.  
La fonction de Raycast crée un tracé de rayon à partir de la position des pieds, vers le bas avec "Vector3.down", et d'une distance de 0.1f. La suite du saut est implémentée dans FixedUpdate après le déplacement de la position. L'implémentation consiste à mettre la vélocité en Y du Rigidbody à une certaine valeur. Nous voulons que, lorsque le bouton est relâché ou lorsqu'un certain temps est atteint, le saut est considéré comme arrêté et complet. Vous pouvez ajouter à FixedUpdate:

```
    if (isJumpingButtonDown && isGrounded && !isJumpActivated)
    {
        isJumping = true;
        StartCoroutine(JumpTimerCoroutine());
    }
    if (isJumping && !isJumpingButtonDown)
    {
        isJumpActivated = false;
    }
    if (isJumpActivated)
    {
        Vector3 velocityBeforeJump = Body.velocity;
        velocityBeforeJump.y = JumpForce;
        Body.velocity = velocityBeforeJump;
    }
```

On utilise les Coroutines afin de faire un compteur de temps. Lorsque le saut doit être activé, la coroutine est démarrée et elle est exécutée en manière séquentielle par rapport au reste du code. Contrairement à appeler une fonction, la coroutine n'arrête pas l'exécution courante, ce qui permet de poursuivre l'exécution du code du joueur. Dans la coroutine, on active le saut, on attend pour le temps de saut voulu, et puis on désactive le saut.

#### Matériels
Présentement, le joueur est de la même couleur que le sol. Une manière de changer sa couleur est d'appliquer un matériel. Dans la fenêtre projet, vous pouvez faire un clic droit, puis Create, et Material. Vous pouvez sélectionner le matériel dans la fenêtre projet et dans l'inspecteur vous pouvez changer le Albedo pour modifier la couleur du matériel. Pour appliquer le matériel, il suffit de cliquer et glisser le matériel jusqu'à la fenêtre de scène et de le relâcher sur l'objet voulu.

## Prefabs, Particules et Animations
Dans le code, vous pouvez remarquer à certains endroits des appels à l'animateur. Pour l'atelier, nous allons ajouter un système de particules au saut et il sera contrôlé par le système d'animations de Unity.

#### Prefabs
Les "Prefabs" sont en quelque sorte un objet de la scène que l'on souhaite sérialiser, c'est-à-dire en faire un objet qui sera présent dans les Assets. Il y a plusieurs avantages à faire des prefabs, comme le fait que notre joueur ne dépendra plus du niveau, on pourra le réutiliser dans n'importe quel niveau, et on peut instancier un prefab par code pour générer des objets par exemple. Pour créer le prefab du joueur, il suffit de sélectionner le joueur dans la hiérarchie du niveau, et de le glisser dans la fenêtre Project. Son nom dans la hiérarchie deviendra bleu, et il sera maintenant possible de modifier le joueur directement en l'ouvrant à partir de la fenêtre Project, ce qui modifiera toutes les instances du joueur présent dans les niveaux. 

#### Particules
Le système de particules de Unity permet de faire de très nombreux effets visuels variés. Vous pouvez ouvrir le prefab du joueur et lui ajouter un GameObject pour les particules avec un clic droit dans la hiérarchie suivi de Effects/Particle System. En sélectionnant le particle system dans la hiérarchie, celui-ci devient configurable dans l'inspecteur et un aperçu est affiché dans la fenêtre de scène. Quelques changements sont nécessaires pour le système: on veut qu'il projette vers le bas, que les particules passent d'un gris foncé de départ jusqu'au noir et puis au transparent, et on veut que les particules entrent en collision avec le sol pour que les particules ne passent pas au travers. 
Je vous suggère fortement d'ouvrir le projet fourni afin de voir les différents réglages et de comprendre les changements faits par rapport au système de particules de base. Par défaut, les particules agissent comme si elles étaient enfant du GameObject qui contient la composante de Particle System. Pour que les particules puissent être créées puis envoyées dans le monde sans suivre le joueur, il faut changer l'option Simulation Space à World. Sa forme doit également être changée, vous pouvez donc aller dans Shape, sélectionner un cône, puis configurer l'angle et le rayon du cône. Vous pouvez tourner le système de particules pour que sa rotation soit à 90 en X et le mettre à une position semblable à celle des pieds, et le système devrait maintenant projeter les particules vers le bas. Vous pouvez aussi changer la vitesse de départ ainsi que les paramètres d'émission afin de projeter un plus grand nombre de particules. Vous pouvez mettre la Duration et le Start Lifetime à 1. Vous pouvez activer "Color over Lifetime" dans l'inspecteur pour que la couleur des particules puisse changer. Dans "Color over Lifetime", vous pouvez cliquer sur la couleur afin d'ouvrir un éditeur de gradient qui vous permettra de changer la couleur de départ, de fin, et la transparence. Pour activer la collision, vous pouvez activer "Collision" dans l'inspecteur. Nous voulons que ces particules entrent en collisions avec certains objets mais pas nécessairement tous les objets, comme le joueur par exemple. Pour exclure certaines collisions, il faut créer une nouvelle couche, soit une nouvelle Layer. Vous pouvez retourner dans la scène (il suffit de cliquer sur le bouton à gauche du nom du prefab dans la hiérarchie, la flèche qui pointe vers la gauche), sélectionner le sol, et vous pourrez constater que le Layer, dans l'inspecteur, n'est pas configuré pour le sol. Vous pouvez cliquer sur le menu déroulant, faire Add Layer, puis créer un Layer nommé Ground. Assurez-vous que le sol possède maintenant ce Layer, puis réouvrez le prefab du joueur pour sélectionner le particle system et changer l'option "Collides With" pour la mettre à "Ground".

#### Animations
Vous devriez maintenant avoir, lorsque vous exécutez le jeu: un joueur qui se déplace sur le niveau, qui saute, et qui projette des particules vers le bas. Par contre, nous voulons que les particules ne soient projetés que lorsque le joueur est en saut. Pour se faire, nous allons utiliser le système d'animations de Unity. Ce système n'est pas utile qu'aux animations, il s'agit avant tout d'un système constitué d'une machine à états. Dans le prefab du joueur, sélectionnez le GameObject racine, puis ajoutez lui la composante "Animator". Dans le projet, vous pouvez ajouter un dossier Player dans lequel on peut mettre le prefab du joueur, et dans lequel vous pouvez créer un Animator Controller avec le clic droit suivi de Create. Vous devez maintenant lier le fichier créé à la composante présente dans le GameObject du joueur. Vous pouvez cliquer sur le Animator Controller dans la fenêtre Project, et le glisser dans le champ "Controller" de la composante "Animator" du GameObject du joueur. Lorsque vous double cliquez dans la fenêtre Project sur le contrôleur créé, une fenêtre Animator devrait s'ouvrir. Vous pouvez sélectionner le nom de la fenêtre et la glisser à côté du nom de la fenêtre scène, ou mettre la fenêtre où vous voulez. Si vous voulez animer le joueur, ce sera avec ce contrôleur. Pour le but de l'atelier, on se contentera de contrôler le système de particules. Vous pouvez créer une nouvelle Layer d'animation en sélectionnant l'onglet Layer de la fenêtre d'Animator, puis en cliquant sur le "+". Vous pouvez nommer la Layer "Thrusters". Pour que cette Layer s'applique, assurez vous de cliquer sur la roulette d'option de la Layer, et de mettre le Weight à 1. Il n'y aura que deux animations nécessaires: ThrustersStart et ThrustersStop. Vous pouvez les créer dans la fenêtre Project de la même manière que vous avez créé le Animator Controller, leur donner le nom voulu, puis les sélectionner et les glisser dans la fenêtre de Animator pour les ajouter au contrôleur. On voudra une transition de ThrustersStart à ThrustersStop et une transition de ThrustersStop à ThrustersStart. Vous pouvez faire un clic droit sur un état, faire "Make Transition", puis cliquer sur l'état suivant. Vous devez sélectionner les transitions et désactiver l'option "Has Exit Time", ce qui forcera Unity à vous demander d'établir une condition de transition. Pour ce faire, vous devez créer un paramètre d'animation. Vous devez donc cliquer sur l'onglet Parameters, créer un nouveau booléen appelé IsThrustersActivated. Nous activerons et désactiverons ce booléen dans le code, ce qui permettra au système de faire les transitions.
Dans le code, vous pouvez créer la variable d'Animator, utiliser ```[SerializeField]```, faire le lien entre la composante Animator du GameObject dans la variable Animator du script de la même manière que pour le Rigidbody et le FeetTransform. Il suffit maintenant d'ajouter ```Animator.SetBool("IsThrustersActivated", true);``` pour causer la transition, et à ```false``` pour causer la transition inverse. Vous pouvez ajouter cette ligne à la fin de la coroutine, et dans les ```if``` de FixedUpdate. D'une manière similaire, si l'on souhaite passer un paramètre de type float, on utiliserait SetFloat. 

Maintenant il faut ajouter de l'information dans les animations afin que celles-ci puissent en effet activer et désactiver le système de particules. Vous pouvez faire Window/Animation/Animation pour ouvrir la fenêtre qui permet de modifier une animation. Lorsque vous aurez ouvert le prefab du joueur et sélectionné son GameObject qui possède la composante Animator, la fenêtre Animation aura un menu déroulant contenant toutes les animations du contrôleur d'animation. Les deux animations serviront à activer et désactiver le GameObject contenant le système de particules. Dans l'animation ThrustersStart, vous pouvez faire "Add Property", ouvrir le GameObject du Particle System, et cliquer sur le "+" de "Is Active". Maintenant, dans les propriétés animées, l'état du Particle System est disponible. Au début de l'animation il y aura maintenant une "Key Frame" qui est ajoutée et qui est sous forme d'un losange dans la ligne du temps de l'animation. Une "Key Frame" représente une trame d'animation où les valeurs sont changées. Vous devez avoir une key frame au tout début et une à 1:00. La même chose doit être faite pour ThrustersStop, mais à la fin de ThrustersStop, il faut que la valeur du "Is Active" soit mis à False. Lorsque vous exécutez le jeu, le système de particules devrait être activé lorsque vous sautez. Les particules disparaissent présentement toutes en même temps lorsque le GameObject est désactivé. Le système doit en fait arrêter de créer des particules au moment que le saut est désactivé et que la transition est faite. Pour arrêter de projeter des particules sans faire disparaitre celles qui existent déjà, il faut utiliser la fonction "Stop" et la fonction "Play" du Particle System. Nous allons donc utiliser les événements qui peuvent être invoqués lors des animations. Vous pouvez aller dans le code du Player Movement et y ajouter une variable ParticleSystem avec l'attribut SerializeField, et lier à cette variable le GameObject qui a le ParticleSystem dans l'éditeur. Vous pouvez maintenant ajouter:

```
public void StopThrusters()
{
    ThrusterParticles.Stop();
}    
    
public void StartThrusters()
{
    ThrusterParticles.Play();
}
```

Comme ces fonctions sont publiques, il sera possible de les sélectionner pour les exécuter dans l'animation. Vous pouvez retourner dans l'éditeur, à la fenêtre Animation. Prenez soin d'ouvrir le prefab du joueur, et d'avoir le GameObject du joueur sélectionné dans la hiérarchie, sinon la fenêtre Animation peut montrer les animations mais si le joueur n'est pas sélectionné, il ne sera pas possible de choisir la fonction du joueur à exécuter. Avec l'animation de ThrustersStop sélectionnée et avec le curseur à la première trame de l'animation, vous pouvez cliquer sur le bouton en forme de rectangle blanc qui a un petit "+" au coin inférieur droit. Celui-ci permet d'indiquer au système d'animation qu'une fonction sera invoquée à ce moment de l'animation. Avec un clic sur l'événement dans la ligne de temps de l'animation, l'inspecteur affiche maintenant un choix de fonction, vous pouvez simplement choisir la fonction StopThrusters. La même chose doit être faite avec l'animation de ThrustersStart et avec la fonction StartThrusters. Lorsque vous démarrez le jeu, vous devriez maintenant avoir des particules qui sont émises lorsque vous sautez et l'émission devrait être arrêtée lorsque le joueur se met à redescendre. Il y a probablement des manières plus simples d'arriver à ce même résultat, par exemple en appelant la fonction Play ou Stop directement au lieu de passer par un booléen et par le système d'animation, mais cette manière permet de vous familiariser avec ce système qui est essentiel dans Unity et qui permet de faire un très grand nombre de choses, et permet d'avoir un certain contrôle sur le temps auquel les particules sont arrêtées. Par exemple, d'autres éléments d'animations pourraient être changés, comme un réacteur qui change d'échelle pour montrer un changement, et donc il pourrait être pertinent d'attendre pour un nombre précis de trames avant d'invoquer la fonction pour arrêter les particules.

## Caméra, Collectibles et Plateformes

#### Caméra
Un jeu comme celui-ci nécessite un système de caméras. Pour cet atelier, nous nous limiterons à une caméra très simple qui s'occupe uniquement de suivre le joueur. Vous pouvez donc revenir dans la scène, sélectionner l'objet Main Camera, puis lui ajouter une composante sous forme de nouveau script nommé "CameraMovement". Dans ce script, il suffit d'obtenir une référence au joueur, et de mettre à jour la position de la caméra selon la position du joueur. Vous pouvez tout simplement créer une variable Transform avec l'attribut [SerializeField] et lier à ce Transform le Transform du GameObject du joueur présent dans la scène. Ainsi, la caméra aura accès à la position du joueur. Vous pouvez ensuite créer une variable Vector3 qui contiendra le décalage entre la position de la caméra et la position du joueur. Vous pouvez, dans le FixedUpdate du script ajouté à la caméra, faire ```transform.position = subject.position + offset;``` ce qui forcera la position de la caméra à être exactement égale à celle de son sujet d'observation (le joueur), avec le décalage déterminé. Si vous mettez [SerializeField] devant la variable du décalage, il sera possible de le configurer dans l'éditeur et de choisir les variables. Une bonne manière de le faire est de démarrer le jeu et de changer les valeurs du vecteur de décalage dans l'inspecteur. Notez par contre que lorsque le jeu est arrêté, les valeurs changées lors de l'exécution ne sont pas sauvegardées, c'est pourquoi avant d'arrêter l'exécution, vous devez cliquer sur les trois points alignés verticalement à droite du nom de la composante Camera Movement dans l'inspecteur, et faire "Copy Component". Une fois le jeu arrêté, vous pourrez cliquer sur le même bouton et faire "Paste Component Values" pour rétablir les valeurs que vous aviez en jeu. Pour la simplicité, vous pouvez ajuster également la Rotation du Transform de la caméra afin de cibler le joueur. Vous pouvez également faire ```transform.LookAt(subject);``` dans le FixedUpdate de la caméra, ce qui assure que la caméra regarde toujours le joueur. Cette méthode peut être suffisante dans certains cas, mais en temps normal il est plutôt restrictif de forcer la caméra à regarder de la même manière le même objet en tout temps. Pour l'objectif de cet atelier, l'une ou l'autre des méthodes suffisent, mais pour avoir une bonne caméra, il est important de réfléchir à comment vous voulez que la caméra suive votre joueur.

#### Collectible
La plupart des jeux de type Platformer contiennent des objets que l'on peut ramasser. Vous pouvez faire un clic droit dans la hiérarchie de la scène et faire un objet vide nommé "Collectible" avec Create Empty. Vous pouvez ensuite faire un GameObject enfant du collectible avec un clic droit, et 3D Object/Sphere. Vous pouvez ensuite placer le collectible où vous voulez, et lui donner la composante Rigidbody. Celle-ci est importante pour détecter les collisions. Assurez-vous de désactiver l'option "Use Gravity", nous voulons uniquement que le collectible reste sur place. Vous pouvez activer les contraintes de Rigidbody pour empêcher les changements de positions et de rotations. Par contre, nous voudrons animer légèrement le collectible pour qu'il attire l'attention, alors laissez le Freeze Position Y désactivé. Vous pouvez maintenant ajouter la composante Animator au collectible, créer un Animator Controller dans la fenêtre Project et lier le Controller à la composante du collectible. Le collectible nécessite deux animations: Un "Idle" qui jouera en boucle, et un "Collect" qui sera joué lorsque le joueur entre en collision avec le collectible. Pour que l'animation Idle soit jouée en boucle, vous devez la sélectionner dans la fenêtre Project, et activer l'option "Loop Time". Vous pouvez ajouter le Idle à l'Animator Controller, puis ajouter le Collect et créer une transition de Idle à Collect. Vous devez désactiver le "Has Exit Time" de la transition, ajouter le paramètre booléen "IsCollected" dans le Animator Controller, puis l'utiliser dans la transition. Pour l'animation Idle, vous pouvez simplement faire Add Property, et sélectionner la position du GameObject avec la sphère. Faites en sorte d'avoir une key frame au début de l'animation, puis une key frame à la fin de l'animation (à 0:30) avec la même position. Vous pouvez ajouter une key frame au milieu de l'animation et changer le Y de la position dans les propriétés de la fenêtre d'animation afin de faire bouger de bas en haut le collectible. Dans l'animation Collect, vous pouvez ajouter les propriétés que vous voulez animer. Par exemple, vous pouvez ajouter la position pour faire monter dans les airs le collectible, vous pouvez ajouter le scale pour faire rétrécir le collectible, vous pouvez ajouter le Mesh Renderer.Material._Color pour modifier le canal "a" et ainsi donner de la transparence au collectible pour qu'il devienne graduellement invisible. Assurez-vous d'abord que le matériel soit en mode "Transparent" en sélectionant le matériel, et en changeant dans l'inspecteur le Rendering Mode pour Transparent. Vous pouvez aussi ajouter la composante Sphere Collider comme propriété de l'animation Collect pour le désactiver lorsque l'animation de Collect débute.

Vous pouvez maintenant ajouter une nouvelle composante au collectible sous forme de script nommé "Collectible". Dans ce script, il faudra une variable Animator, avec l'attribut ```[SerializeField]```, qui doit être liée à la composante Animator du collectible. Dans le script du collectible, vous pouvez ajouter:

```
    private void OnCollisionEnter(Collision collision)
    {
        Animator.SetBool("IsCollected", true);
    }
```

Il s'agit de la fonction qui permet de réagir à la collision. C'est une fonction de Unity qui est appelée automatiquement lorsqu'une collision est enclenchée et que l'objet possède un collider et un Rigidbody.

Pour que le collectible soit détruit et donc retiré de la scène, vous pouvez ajouter la fonction suivante au code:

```
    public void RemoveCollectible()
    {
        Destroy(gameObject);
    }
```

Vous pouvez ajouter un événement à la fin de l'animation Collect pour appeler cette fonction, et celle-ci s'occupera de détruire le GameObject qui possède la composante puisque vous passez la référence gameObject à Destroy.

#### Plateformes
L'ajout de plateformes est important et peut être fait assez facilement. Vous pouvez simplement ajouter un GameObject Cube à la scène et changer les valeurs du Scale et de sa position pour le placer où vous voulez. N'oubliez pas de lui donner le Layer "Ground" afin que les particules ne passent pas au travers de la plateforme! 

## Conclusion
Avec tous ces concepts en main, vous aurez un bon départ pour créer un jeu dans Unity. N'hésitez pas à chercher dans la documentation de Unity, celle-ci est souvent bien détaillée et avec un engin de recherche il est rare qu'une question que vous vous posez ne soit pas déjà répondre quelque part. Vous pouvez tenter d'ajouter un "nez" à votre joueur pour voir où il pointe, et modifier le code afin que sa rotation soit alignée avec son déplacement! Vous pouvez aussi chercher sur internet pour trouver un modèle qui servirait de joueur, je vous conseille de commencer par le Asset Store de Unity qui contient beaucoup de ressources gratuites. Beaucoup de choses peuvent être faites avec les collisions également, vous pourriez faire des ennemis pour votre joueur et créer des collisions sur les côtés qui donnent des dégâts au joueur et une collision sur le dessus qui peut vaincre l'ennemi, ou vous pourriez aussi faire des obstacles.
J'espère que ce tutoriel vous a été utile et je vous souhaite bonne chance avec la suite de votre apprentissage sur le développement de jeu vidéo!





